### [KMJ]

```cpp
#if 1
// [김민재] WS 493 ms
#define MAX_N 100000
#define MAX_L 320
#define MAX_P (100000 / MAX_L + 1)
#define LEFT 0
#define RIGHT 1

inline int max(int a, int b) { return a > b ? a : b; }
inline int min(int a, int b) { return a < b ? a : b; }
int endLoc;
int box[MAX_N];

struct Partition {
	int st, ed;
	int topLoc;

	void addBox(int mLoc, int mBox) {
		box[mLoc] += mBox;
		topLoc = st;

		for (int i = st; i < ed; i++) {
			if (box[i] > box[topLoc])
				topLoc = i;
		}
	}

	int getTopLocOnTheLeft(int from, int to) {
		int loc = max(st, from);
		int end = min(ed, to);

		for (int i = loc; i < end; i++) {
			if (box[i] > box[loc])
				loc = i;
		}
		return loc;
	}

	int getTopLocOnTheRight(int from, int to) {
		int loc = max(st, from);
		int end = min(ed, to);

		for (int i = loc; i < end; i++) {
			if (box[i] >= box[loc])
				loc = i;
		}
		return loc;
	}
};
Partition partition[MAX_P];

int getPartitionId(int mLoc) { return mLoc / MAX_L; }

int getTopLocOnTheLeft(int st, int ed) { // st <= n < ed
	int topLoc = st;
	int sp = getPartitionId(st);
	int ep = getPartitionId(ed - 1);
	int loc;

	for (int i = sp; i <= ep; i++) {
		if (st <= partition[i].st && partition[i].ed <= ed)
			loc = partition[i].topLoc;
		else
			loc = partition[i].getTopLocOnTheLeft(st, ed);

		if (box[loc] > box[topLoc])
			topLoc = loc;
	}
	return topLoc;
}

int getTopLocOnTheRight(int st, int ed) { // st <= n < ed
	int topLoc = st;
	int sp = getPartitionId(st);
	int ep = getPartitionId(ed - 1);
	int loc;

	for (int i = sp; i <= ep; i++) {
		if (st <= partition[i].st && partition[i].ed <= ed)
			loc = partition[i].topLoc;
		else
			loc = partition[i].getTopLocOnTheRight(st, ed);

		if (box[loc] >= box[topLoc])
			topLoc = loc;
	}
	return topLoc;
}

int putUpLeftSide(int ed) {
	if (ed == 0)
		return 0;
	int loc = getTopLocOnTheLeft(0, ed);
	return box[loc] * (ed - loc) + putUpLeftSide(loc);
}

int putUpRightSide(int st) {
	if (st == endLoc)
		return 0;
	int loc = getTopLocOnTheRight(st, endLoc);
	return box[loc] * (loc + 1 - st) + putUpRightSide(loc + 1);
}

///////////////////////////////////////////////////////////////////////////////////////
void init(int N)
{
	endLoc = N + 1;
	int maxPartitionId = N / MAX_L;

	for (int i = 0; i <= N; i++) {
		box[i] = 0;
	}

	for (int i = 0; i <= maxPartitionId; i++) {
		partition[i].st = i * MAX_L;
		partition[i].ed = (i + 1) * MAX_L;
		partition[i].topLoc = partition[i].st;
	}
}

int stock(int mLoc, int mBox)
{
	// 1. 가장 높은 위치 k를 찾는다.
	// 2. k의 왼쪽 방향으로 천막을 덮으면서 덮힌 넓이도 구한다.
	// 3. k의 오른쪽 방향으로 천막을 덮으면서 덮힌 넓이도 구한다.
	// 4. 넓이를 다 더해서 리턴한다.

	partition[getPartitionId(mLoc)].addBox(mLoc, mBox);
	int loc = getTopLocOnTheLeft(0, endLoc);
	return putUpLeftSide(loc) + box[loc] + putUpRightSide(loc + 1);
}

int ship(int mLoc, int mBox)
{
	return stock(mLoc, -mBox);
}

int getHeight(int mLoc)
{
	return box[mLoc];
}
#endif
```

### [김진환]

```cpp
// [김진환] WS 138 ms

struct SData
{
    int val;
    int idx;
};

SData _data[1 << 18];
int _offset;
int _size;

void _init(int size)
{
    _size = size;
    _offset = 1;

    while (size > _offset)
        _offset <<= 1;

    for (int i = _offset - 1; i >= 0; i--)
        _data[i].val = 0, _data[i].idx = -1;

    for (int i = _offset, j = 0; i < _offset * 2; i++, j++)
        _data[i].val = 0, _data[i].idx = j;
}

void _update(int idx, int diff)
{
    idx += _offset;
    _data[idx].val += diff;

    while (idx > 1)
    {
        idx >>= 1;
        if (_data[idx * 2].val > _data[idx * 2 + 1].val)
            _data[idx] = _data[idx * 2];
        else
            _data[idx] = _data[idx * 2 + 1];
    }
}

SData _get(int s, int e)
{
    SData ret = { 0,-1 };

    if (s > e)
        return ret;

    s += _offset;
    e += _offset;

    while (s < e)
    {
        if (s & 1)
        {
            if (ret.val < _data[s].val)
                ret = _data[s];
            s += 1;
        }

        if ((e & 1) == 0)
        {
            if (ret.val < _data[e].val)
                ret = _data[e];
            e -= 1;
        }

        s >>= 1;
        e >>= 1;
    }

    if (ret.val < _data[s].val)
        ret = _data[s];

    return ret;
}

int getResult()
{
    SData MaxCenter = _get(0, _size - 1), MaxPos;
    int ret = MaxCenter.val;

    int idx = MaxCenter.idx;
    while (1)
    {
        MaxPos = _get(0, idx - 1);
        if (MaxPos.val == 0 || MaxPos.idx == -1)
            break;

        ret += MaxPos.val * (idx - MaxPos.idx);
        idx = MaxPos.idx;
    }

    idx = MaxCenter.idx;
    while (1)
    {
        MaxPos = _get(idx + 1, _size - 1);
        if (MaxPos.val == 0 || MaxPos.idx == -1)
            break;

        ret += MaxPos.val * (MaxPos.idx - idx);
        idx = MaxPos.idx;
    }
    return ret;
}


//////////////////////////////////////////////////////////////
void init(int N)
{
    _init(N);
}

int stock(int mLoc, int mBox)
{
    _update(mLoc - 1, mBox);
    return getResult();
}

int ship(int mLoc, int mBox)
{
    _update(mLoc - 1, -mBox);
    return getResult();
}

int getHeight(int mLoc)
{
    return _data[mLoc - 1 + _offset].val;
}
```
