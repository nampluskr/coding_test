### [KMJ]

```cpp
#include <string.h>
 #define MAXN   (500)
 #define MAXL   (11)
 #define A   (0)
 #define B   (1)

struct Company {
    char name[MAXL];
    int country;
    int groupId;
};
 
Company company[2 * MAXN];
 
struct CompanyGroup {
    int companyCount;
    int cIDs[MAXN];
    int country;
    bool isRemoved;
    int numberOfProjectsWithOtherGroup[2 * MAXN];
 
    void init() {
        companyCount = 0;
        isRemoved = false;
 
        for (int i = 0; i < 2 * MAXN; i++) {
            numberOfProjectsWithOtherGroup[i] = 0;
        }
    }
 
    void add(int cID) { cIDs[companyCount++] = cID; }
    void startProject(int groupId) { numberOfProjectsWithOtherGroup[groupId]++; }
    void finishProject(int groupId) { numberOfProjectsWithOtherGroup[groupId]--; }
 
};
 
CompanyGroup companyGroup[2 * MAXN];
 
int companyCount;
 
void makeCompany(int country, int mNum, char mCompanyList[MAXN][MAXL]) {
    for (int i = 0; i < mNum; i++) {
        int cID = companyCount++;
        int gID = cID;
 
        strcpy(company[cID].name, mCompanyList[i]);
        company[cID].country = country;
        company[cID].groupId = gID;
 
        companyGroup[gID].init();
        companyGroup[gID].add(cID);
        companyGroup[gID].country = country;
    }
}
 
int getCompanyId(char name[MAXL]) {
    for (int i = 0; i < companyCount; i++) {
        if (strcmp(company[i].name, name) == 0)
            return i;
    }
    return -1;
}
 
 
void init(int mNumA, char mCompanyListA[MAXN][MAXL], int mNumB, char mCompanyListB[MAXN][MAXL])
{
    companyCount = 0;
    makeCompany(A, mNumA, mCompanyListA);
    makeCompany(B, mNumB, mCompanyListB);
}
 
void startProject(char mCompanyA[MAXL], char mCompanyB[MAXL])
{
    int groupA = company[getCompanyId(mCompanyA)].groupId;
    int groupB = company[getCompanyId(mCompanyB)].groupId;
    companyGroup[groupA].startProject(groupB);
    companyGroup[groupB].startProject(groupA);
}
 
void finishProject(char mCompanyA[MAXL], char mCompanyB[MAXL])
{
    int groupA = company[getCompanyId(mCompanyA)].groupId;
    int groupB = company[getCompanyId(mCompanyB)].groupId;
    companyGroup[groupA].finishProject(groupB);
    companyGroup[groupB].finishProject(groupA);
}
 
void ally(char mCompany1[MAXL], char mCompany2[MAXL])
{
    int dst = company[getCompanyId(mCompany1)].groupId;
    int src = company[getCompanyId(mCompany2)].groupId;
 
    if (dst == src) // 이미 동맹이라면
        return;
 
    companyGroup[src].isRemoved = true;
 
    for (int i = 0; i < companyGroup[src].companyCount; i++) {
        int cID = companyGroup[src].cIDs[i];
        companyGroup[dst].add(cID);
        company[cID].groupId = dst;
    }
 
    for (int i = 0; i < companyCount; i++) {
        // dst에게 src의 협업정보를 이관한다.
        companyGroup[dst].numberOfProjectsWithOtherGroup[i] += companyGroup[src].numberOfProjectsWithOtherGroup[i];
        // 이제 src가 없어졌으니 src랑 협업하던 프로젝트를 dst랑 하는 걸로 수정한다.
        companyGroup[i].numberOfProjectsWithOtherGroup[dst] += companyGroup[i].numberOfProjectsWithOtherGroup[src];
    }
}
 
int conflict(char mCompany1[MAXL], char mCompany2[MAXL])
{
    int group1 = company[getCompanyId(mCompany1)].groupId;
    int group2 = company[getCompanyId(mCompany2)].groupId;
    int sum = 0;
 
    for (int i = 0; i < companyCount; i++) {// 모든 group에 대해서
        if (companyGroup[i].isRemoved)
            continue;
        if (companyGroup[i].numberOfProjectsWithOtherGroup[group1] == 0)
            continue;
        if (companyGroup[i].numberOfProjectsWithOtherGroup[group2] == 0)
            continue;
        sum += companyGroup[i].companyCount;
    }
 
    return sum;
}
```
