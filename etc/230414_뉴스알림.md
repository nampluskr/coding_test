### [STL]

```cpp
#include <vector>
#include <unordered_map>
#include <queue>
using namespace std;

#define NUM_NEWS		30001
#define NUM_USERS		501
#define NUM_CHANNELS	501

#define CANCELED	1

// channel > user > news
struct News {
    int nIdx;
    int newsID;
    int cIdx;			// channel index
    int alarm_time;		// mTime + mDelay
    int state;

    bool operator<(const News& data) const { return alarm_time > data.alarm_time; }
};
struct User {
    vector<int> newsList;
};
struct Channel {
    vector<int> userList;
};

// mTime: 현재 시각(1 ≤ mTime ≤ 1,000,000,000)
vector<News> news;			// mNewsID : 뉴스의 ID (1 ≤ mNewsID ≤ 1,000,000,000 )
vector<Channel> channels;	// mChannelID : 뉴스를 제공받는 뉴스 채널의 ID ( 1 ≤ mChannelID ≤ 1,000,000,000 )
vector<User> users;			// mUID: 유저의 ID ( 1 ≤ mUID ≤ 1,000,000,000 )

unordered_map<int, int> newsMap;
unordered_map<int, int> channelMap;
unordered_map<int, int> userMap;

int newsCnt;
int channelCnt;
int userCnt;

priority_queue<News> newsPQ;

struct Data {
    int newsID;
    int alarm_time;

    bool operator<(const Data& data) const {
        return (alarm_time < data.alarm_time) ||
            (alarm_time == data.alarm_time && newsID < data.newsID);
    }
};

//////////////////////////////////////////////////////////////////////////////
int get_newsIndex(int mNewsID) {
    int nIdx;
    auto ptr = newsMap.find(mNewsID);
    if (ptr == newsMap.end()) {
        nIdx = newsCnt;
        newsMap[mNewsID] = nIdx;
        newsCnt += 1;
    }
    else { nIdx = ptr->second; }
    return nIdx;
}
int get_channelIndex(int mChannelID) {
    int cIdx;
    auto ptr = channelMap.find(mChannelID);
    if (ptr == channelMap.end()) {
        cIdx = channelCnt;
        channelMap[mChannelID] = cIdx;
        channelCnt += 1;
    }
    else { cIdx = ptr->second; }
    return cIdx;
}
int get_userIndex(int mUID) {
    int uIdx;
    auto ptr = userMap.find(mUID);
    if (ptr == userMap.end()) {
        uIdx = userCnt;
        userMap[mUID] = uIdx;
        userCnt += 1;
    }
    else { uIdx = ptr->second; }
    return uIdx;
}

void update_news(int mTime) {
    auto& Q = newsPQ;
    while (!Q.empty() && Q.top().alarm_time <= mTime) {
        auto data = Q.top(); Q.pop();

        if (news[data.nIdx].alarm_time != data.alarm_time) continue;

        if (news[data.nIdx].state != CANCELED) {
            for (int uIdx : channels[data.cIdx].userList) {
                users[uIdx].newsList.push_back(data.nIdx);
            }
        }
    }
}

//////////////////////////////////////////////////////////////////////////////
// N: 뉴스 알림을 받는 유저의 수(1 ≤ N ≤ 500)
// K: 뉴스 알림을 보내는 뉴스 채널의 수(1 ≤ K ≤ 500)
void init(int N, int K)
{
    newsMap.clear();
    channelMap.clear();
    userMap.clear();

    news.clear();		news.resize(NUM_NEWS);
    channels.clear();	channels.resize(NUM_CHANNELS);
    users.clear();		users.resize(NUM_USERS);

    newsCnt = 0;
    channelCnt = 0;
    userCnt = 0;

    while (!newsPQ.empty()) { newsPQ.pop(); }
}

// 5,000
void registerUser(int mTime, int mUID, int mNum, int mChannelIDs[])
{
    update_news(mTime);

    int uIdx = get_userIndex(mUID);
    for (int i = 0; i < mNum; i++) {
        int cIdx = get_channelIndex(mChannelIDs[i]);

        //users[uIdx].cIdx = cIdx;
        channels[cIdx].userList.push_back(uIdx);
    }
}

// 30,000
int offerNews(int mTime, int mNewsID, int mDelay, int mChannelID)
{
    update_news(mTime);

    int nIdx = get_newsIndex(mNewsID);
    int cIdx = get_channelIndex(mChannelID);

    news[nIdx].nIdx = nIdx;
    news[nIdx].newsID = mNewsID;
    news[nIdx].cIdx = cIdx;
    news[nIdx].alarm_time = mTime + mDelay;

    newsPQ.push(news[nIdx]);

    return channels[cIdx].userList.size();
}

// 3,000
void cancelNews(int mTime, int mNewsID)
{
    update_news(mTime);

    int nIdx = get_newsIndex(mNewsID);
    news[nIdx].state = CANCELED;
}

// 1,000
int checkUser(int mTime, int mUID, int mRetIDs[])
{
    update_news(mTime);

    int ret = 0;
    int uIdx = get_userIndex(mUID);
    priority_queue<Data> Q;

    // 힙정렬
    for (int nIdx : users[uIdx].newsList) {
        if (news[nIdx].state != CANCELED) {
            Q.push({ news[nIdx].newsID, news[nIdx].alarm_time });
        }
    }
    ret = Q.size();

    int cnt = 0;
    while (!Q.empty() && cnt < 3) {
        auto data = Q.top(); Q.pop();

        mRetIDs[cnt] = data.newsID;
        cnt += 1;
    }
    // 함수 호출 후, mUID 유저가 받은 뉴스 알림은 모두 삭제되어 알림의 개수는 0 이 된다.
    users[uIdx].newsList.clear();
    return ret;
}
```
