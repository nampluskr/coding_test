### [KMJ]

```cpp
#include <queue>
#define MAX_WAREHOUSE      3
#define MAX_TYPE           3
#define MAX_PARTS       4000
#define MAX_BUDGET   1000000
#define WAREHOUSE_A        0
#define WAREHOUSE_B        1
#define WAREHOUSE_AB_TOTAL 2

using namespace std;

struct Part {
	int type;
	int price;
	int performance;
	int position;
};

Part part[MAX_PARTS];
int charge;
int totalPartCount;
int partCount[MAX_WAREHOUSE][MAX_TYPE];
int lowestPartsPrice[MAX_WAREHOUSE][MAX_TYPE];
int min(int a, int b) { return a < b ? a : b; }
priority_queue<pair<int, int>> partQueue;

struct Result
{
	int mPrice;
	int mPerformance;
};

void init(int mCharge)
{
	totalPartCount = 0;
	charge = mCharge;

	for (int i = 0; i < 3; i++) {
		for (int j = 0; j < 3; j++) {
			partCount[i][j] = 0;
		}
	}
}

int stock(int mType, int mPrice, int mPerformance, int mPosition)
{
	part[totalPartCount].type = mType;
	part[totalPartCount].price = mPrice;
	part[totalPartCount].performance = mPerformance;
	part[totalPartCount].position = mPosition;
	totalPartCount += 1;
	partCount[mPosition][mType] += 1;
	return partCount[mPosition][mType];
}

void updateLowestPartsPrice(Part p) {
	lowestPartsPrice[p.position][p.type] = min(lowestPartsPrice[p.position][p.type], p.price);
	lowestPartsPrice[WAREHOUSE_AB_TOTAL][p.type] = min(lowestPartsPrice[WAREHOUSE_AB_TOTAL][p.type], p.price);
}

void queuePop(int stdPerformance) {
	while (!partQueue.empty() && partQueue.top().first == stdPerformance) {
		pair<int, int> p = partQueue.top();
		updateLowestPartsPrice(part[p.second]);
		partQueue.pop();
	}
}

int getLowestComputerPrice(int priceList[]) {
	return priceList[0] + priceList[1] + priceList[2];
}

int getLowestComputerPrice() {
	int lowestComputerPrice = getLowestComputerPrice(lowestPartsPrice[WAREHOUSE_A]);
	lowestComputerPrice = min(lowestComputerPrice, getLowestComputerPrice(lowestPartsPrice[WAREHOUSE_B]));
	return min(lowestComputerPrice, getLowestComputerPrice(lowestPartsPrice[WAREHOUSE_AB_TOTAL]) + charge);
}

void initLowestPartsPrice() {
	for (int i = 0; i < 3; i++) {
		for (int j = 0; j < 3; j++) {
			lowestPartsPrice[i][j] = MAX_BUDGET;
		}
	}
}

void initPartQueue() {
	while (!partQueue.empty()) {
		partQueue.pop();
	}
}

Result order(int mBudget)
{
	Result res = { 0, 0 };

	initLowestPartsPrice();
	initPartQueue();

	for (int i = 0; i < totalPartCount; i++) {
		partQueue.emplace(part[i].performance, i);
	}

	while (!partQueue.empty()) {
		res.mPerformance = partQueue.top().first;
		queuePop(res.mPerformance);
		res.mPrice = getLowestComputerPrice();

		if (res.mPrice <= mBudget)
			return res;
	}

	res.mPerformance = 0;
	res.mPrice = 0;
	return res;
}
```
