### [Brute Force]

```cpp
#if 0
// (TC = 5) Brute force 992 ms
#ifndef _CRT_SECURE_NO_WARNINGS
#define _CRT_SECURE_NO_WARNINGS
#endif

#include <vector>
#include <cstring>
#include <string>
#include <unordered_map>
using namespace std;

#define NUM_ACCOUNTS    50000
#define MAX_LENGTH      11
#define LOGOUT          1

struct Account {
    char password[MAX_LENGTH];
    int default_time;
    int logout_time;
    int state;
};
vector<Account> accounts;
int accountCnt;

unordered_map<string, int> accountMap;
int current_time;

//////////////////////////////////////////////////////////////////////////////
int get_accountIndex(const char id[]) {
    int aIdx;
    auto ret = accountMap.find(string(id));
    if (ret == accountMap.end()) {
        aIdx = accountCnt;
        accountMap.emplace(string(id), aIdx);
        accountCnt += 1;
    }
    else { aIdx = ret->second; }
    return aIdx;
}

//////////////////////////////////////////////////////////////////////////////
void Init()
{
    accounts.clear();   accounts.resize(NUM_ACCOUNTS);
    accountCnt = 0;
    accountMap.clear();
    current_time = 0;
}

void NewAccount(char id[], char password[], int defaulttime)
{
    int aIdx = get_accountIndex(id);
    strcpy(accounts[aIdx].password, password);
    accounts[aIdx].default_time = defaulttime;
    accounts[aIdx].logout_time = current_time + defaulttime;
}

void Logout(char id[])
{
    int aIdx = get_accountIndex(id);
    accounts[aIdx].state = LOGOUT;
}

void Connect(char id[], char password[])
{
    int aIdx = get_accountIndex(id);
    if (strcmp(accounts[aIdx].password, password) != 0) return;
    if (accounts[aIdx].state == LOGOUT) return;

    accounts[aIdx].logout_time = current_time + accounts[aIdx].default_time;
}

int Tick()
{
    current_time += 1;

    int ret = 0;
    for (int i = 0; i < accountCnt; i++) {
        if (accounts[i].logout_time != current_time) continue;

        if (accounts[i].state != LOGOUT) {
            accounts[i].state = LOGOUT;
            ret += 1;
        }

    }
    return ret;
}
#endif
```

### [STL-1]

```cpp
#if 0
// (TC = 5) STL 102 ms / Brute force 982 ms
#ifndef _CRT_SECURE_NO_WARNINGS
#define _CRT_SECURE_NO_WARNINGS
#endif

#include <vector>
#include <cstring>
#include <string>
#include <unordered_map>
using namespace std;

#define NUM_ACCOUNTS    50000
#define MAX_LENGTH      11
#define LOGOUT          1

struct Account {
    char password[MAX_LENGTH];
    int default_time;
    int logout_time;
    int state;
};
vector<Account> accounts;
int accountCnt;

unordered_map<string, int> accountMap;
int current_time;

unordered_map<int, vector<int>> logoutAccList;

//////////////////////////////////////////////////////////////////////////////
int get_accountIndex(const char id[]) {
    int aIdx;
    auto ret = accountMap.find(string(id));
    if (ret == accountMap.end()) {
        aIdx = accountCnt;
        accountMap.emplace(string(id), aIdx);
        accountCnt += 1;
    }
    else { aIdx = ret->second; }
    return aIdx;
}

//////////////////////////////////////////////////////////////////////////////
void Init()
{
    accounts.clear();   accounts.resize(NUM_ACCOUNTS);
    accountCnt = 0;
    accountMap.clear();
    current_time = 0;
    logoutAccList.clear();
}

void NewAccount(char id[], char password[], int defaulttime)
{
    int aIdx = get_accountIndex(id);
    strcpy(accounts[aIdx].password, password);
    accounts[aIdx].default_time = defaulttime;
    accounts[aIdx].logout_time = current_time + defaulttime;

    logoutAccList[accounts[aIdx].logout_time].push_back(aIdx);
}

void Logout(char id[])
{
    int aIdx = get_accountIndex(id);
    accounts[aIdx].state = LOGOUT;
}

void Connect(char id[], char password[])
{
    int aIdx = get_accountIndex(id);
    if (strcmp(accounts[aIdx].password, password) != 0) return;
    if (accounts[aIdx].state == LOGOUT) return;

    accounts[aIdx].logout_time = current_time + accounts[aIdx].default_time;
    logoutAccList[accounts[aIdx].logout_time].push_back(aIdx);
}

int Tick()
{
    current_time += 1;

    int ret = 0;
    for (int aIdx: logoutAccList[current_time]) {
        if (accounts[aIdx].logout_time != current_time) continue;

        if (accounts[aIdx].state != LOGOUT) {
            accounts[aIdx].state = LOGOUT;
            ret += 1;
        }
    }
    return ret;
}
#endif
```

### [STL-2]

```cpp
#if 0
// (TC = 5) STL-2 92 ms / STL-1 102 ms / Brute force 982 ms
#ifndef _CRT_SECURE_NO_WARNINGS
#define _CRT_SECURE_NO_WARNINGS
#endif

#include <vector>
#include <cstring>
#include <string>
#include <unordered_map>
#include <queue>
using namespace std;

#define NUM_ACCOUNTS    50000
#define MAX_LENGTH      11
#define LOGOUT          1

struct Account {
    char password[MAX_LENGTH];
    int default_time;
    int logout_time;
    int state;
};
vector<Account> accounts;
int accountCnt;

unordered_map<string, int> accountMap;
int current_time;

struct Data {
    int aIdx;
    int logout_time;
    bool operator<(const Data& data) const { return logout_time > data.logout_time; }
};
priority_queue<Data> logoutAccPQ;

//////////////////////////////////////////////////////////////////////////////
int get_accountIndex(const char id[]) {
    int aIdx;
    auto ret = accountMap.find(string(id));
    if (ret == accountMap.end()) {
        aIdx = accountCnt;
        accountMap.emplace(string(id), aIdx);
        accountCnt += 1;
    }
    else { aIdx = ret->second; }
    return aIdx;
}

//////////////////////////////////////////////////////////////////////////////
void Init()
{
    accounts.clear();   accounts.resize(NUM_ACCOUNTS);
    accountCnt = 0;
    accountMap.clear();
    current_time = 0;

    while (!logoutAccPQ.empty()) { logoutAccPQ.pop(); }
}

void NewAccount(char id[], char password[], int defaulttime)
{
    int aIdx = get_accountIndex(id);
    strcpy(accounts[aIdx].password, password);
    accounts[aIdx].default_time = defaulttime;

    int logout_time = current_time + defaulttime;
    accounts[aIdx].logout_time = logout_time;
    logoutAccPQ.push({ aIdx, logout_time });
}

void Logout(char id[])
{
    int aIdx = get_accountIndex(id);
    accounts[aIdx].state = LOGOUT;
}

void Connect(char id[], char password[])
{
    int aIdx = get_accountIndex(id);
    if (strcmp(accounts[aIdx].password, password) != 0) return;
    if (accounts[aIdx].state == LOGOUT) return;

    int logout_time = current_time + accounts[aIdx].default_time;
    accounts[aIdx].logout_time = logout_time;
    logoutAccPQ.push({ aIdx, logout_time });
}

int Tick()
{
    current_time += 1;

    int ret = 0;
    auto& Q = logoutAccPQ;

    while (!Q.empty() && Q.top().logout_time <= current_time) {
        auto data = Q.top(); Q.pop();
        int aIdx = data.aIdx;

        if (accounts[aIdx].logout_time != current_time) continue;

        if (accounts[aIdx].state != LOGOUT) {
            accounts[aIdx].state = LOGOUT;
            ret += 1;
        }
    }
    return ret;
}
#endif
```

### [Manual-1]

```cpp
#if 1
// (TC = 5) Manual-1 78 ms / STL-1 102 ms / Brute force 982 ms
#ifndef _CRT_SECURE_NO_WARNINGS
#define _CRT_SECURE_NO_WARNINGS
#endif

#include <cstring>

#define NUM_ACCOUNTS    50000
#define MAX_LENGTH      11
#define LOGOUT          1
#define MAX_TABLE       50007

template<typename Type>
struct LinkedList {
    struct ListNode {
        Type data;
        ListNode* next;
    };
    ListNode* head = nullptr;
    ListNode* tail = nullptr;

    void clear() { head = nullptr; tail = nullptr; }
    void push_back(const Type& data) {
        ListNode* node = new ListNode({ data, nullptr });
        if (head == nullptr) { head = node; tail = node; }
        else { tail->next = node; tail = node; }
    }
};

template<typename Type>
struct HashChain {
    LinkedList<Type> table[MAX_TABLE];

    void clear() { for (int i = 0; i < MAX_TABLE; i++) table[i].clear(); }
    LinkedList<Type>& operator[](int key) {
        int hashkey = key % MAX_TABLE;
        return table[hashkey];
    }
};

struct HashMap {
    struct Data {
        char key[MAX_LENGTH];
        int value;

        //Data() { strcpy(this->key, ""); this->value = 0; }
        Data(const char key[], int value) { strcpy(this->key, key); this->value = value; }
    };
    LinkedList<Data> table[MAX_TABLE];

    int hash(const char str[]) {
        unsigned long hash = 5381;
        int c;
        while (c = *str++) {
            hash = (((hash << 5) + hash) + c) % MAX_TABLE;
        }
        return hash % MAX_TABLE;
    }
    void clear() { for (int i = 0; i < MAX_TABLE; i++) table[i].clear(); }
    int find(const char key[]) {
        int hashkey = hash(key);
        for (auto node = table[hashkey].head; node; node = node->next) {
            if (strcmp(node->data.key, key) == 0)
                return node->data.value;
        }
        return -1;
    }
    void emplace(const char key[], int value) {
        int hashkey = hash(key);
        table[hashkey].push_back({ key, value });
    }
};

//////////////////////////////////////////////////////////////////////////////

struct Account {
    char password[MAX_LENGTH];
    int default_time;
    int logout_time;
    int state;
};
Account accounts[NUM_ACCOUNTS];
int accountCnt;

HashMap accountMap;
int current_time;

HashChain<int> logoutAccList;

//////////////////////////////////////////////////////////////////////////////
int get_accountIndex(const char id[]) {
    int aIdx;
    auto ret = accountMap.find(id);
    if (ret == -1) {
        aIdx = accountCnt;
        accountMap.emplace(id, aIdx);
        accountCnt += 1;
    }
    else { aIdx = ret; }
    return aIdx;
}

//////////////////////////////////////////////////////////////////////////////
void Init()
{
    for (int i = 0; i < NUM_ACCOUNTS; i++) { accounts[i] = {}; }
    accountCnt = 0;
    accountMap.clear();
    current_time = 0;
    logoutAccList.clear();
}

void NewAccount(char id[], char password[], int defaulttime)
{
    int aIdx = get_accountIndex(id);
    strcpy(accounts[aIdx].password, password);
    accounts[aIdx].default_time = defaulttime;
    accounts[aIdx].logout_time = current_time + defaulttime;

    logoutAccList[accounts[aIdx].logout_time].push_back(aIdx);
}

void Logout(char id[])
{
    int aIdx = get_accountIndex(id);
    accounts[aIdx].state = LOGOUT;
}

void Connect(char id[], char password[])
{
    int aIdx = get_accountIndex(id);
    if (strcmp(accounts[aIdx].password, password) != 0) return;
    if (accounts[aIdx].state == LOGOUT) return;

    accounts[aIdx].logout_time = current_time + accounts[aIdx].default_time;
    logoutAccList[accounts[aIdx].logout_time].push_back(aIdx);
}

int Tick()
{
    current_time += 1;

    int ret = 0;
    for (auto node = logoutAccList[current_time].head; node; node = node->next) {
        int aIdx = node->data;
        if (accounts[aIdx].logout_time != current_time) continue;

        if (accounts[aIdx].state != LOGOUT) {
            accounts[aIdx].state = LOGOUT;
            ret += 1;
        }
    }
    return ret;
}
#endif
```
