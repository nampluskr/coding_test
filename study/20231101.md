### [STL] 서버접속

```cpp
// STL 150 ms (TC = 5)
#ifndef _CRT_SECURE_NO_WARNINGS
#define _CRT_SECURE_NO_WARNINGS
#endif

#include <vector>
#include <string>
#include <unordered_map>
#include <cstring>
using namespace std;

#define MAX_USERS	(30000 + 1)
#define MAX_LEN		(10 + 1)
#define LOGOUT		1
#define MAX_TIME	(50000 + 1)

struct User {
	char password[MAX_LEN];
	int defaultTime;
	int logoutTime;
	int state;
};
User users[MAX_USERS];
int userCnt;
unordered_map<string, int> userMap;

int currentTime;
vector<int> logoutUserList[MAX_TIME];

////////////////////////////////////////////////////////////////////
int get_userIndex(const char id[]) {
	int uIdx;
	auto ptr = userMap.find(string(id));
	if (ptr == userMap.end()) {
		uIdx = userCnt++;
		userMap.emplace(string(id), uIdx);
	}
	else { uIdx = ptr->second; }
	return uIdx;
}
////////////////////////////////////////////////////////////////////
void Init() {
	for (int i = 0; i < MAX_USERS; i++) { users[i] = {}; }
	userCnt = 0;
	userMap.clear();

	currentTime = 0;
	for (int i = 0; i < MAX_TIME; i++) { logoutUserList[i].clear(); }
}

void NewAccount(char id[], char password[], int defaulttime) {
	int uIdx = get_userIndex(id);
	strcpy(users[uIdx].password, password);
	users[uIdx].defaultTime = defaulttime;
	users[uIdx].logoutTime = currentTime + defaulttime;

	logoutUserList[users[uIdx].logoutTime].push_back(uIdx);
}

void Logout(char id[]) {
	int uIdx = get_userIndex(id);
	if (users[uIdx].state != LOGOUT) {
		users[uIdx].state = LOGOUT;
	}
}

void Connect(char id[], char password[]) {
	int uIdx = get_userIndex(id);
	if (strcmp(users[uIdx].password, password) != 0) { return; }
	if (users[uIdx].state != LOGOUT) {
		users[uIdx].logoutTime = currentTime + users[uIdx].defaultTime;
		logoutUserList[users[uIdx].logoutTime].push_back(uIdx);
	}
}

int Tick() { 
	currentTime += 1;
	int ret = 0;

	for (int uIdx: logoutUserList[currentTime]) {
		if (users[uIdx].state == LOGOUT) continue;

		if (users[uIdx].logoutTime == currentTime) { 
			users[uIdx].state = LOGOUT;
			ret += 1;
		}
	}
	return ret;
}
```

### [Manual] 서버접속

```cpp
// Manual 94 ms (TC = 5)
#ifndef _CRT_SECURE_NO_WARNINGS
#define _CRT_SECURE_NO_WARNINGS
#endif

#include <cstring>

#define MAX_USERS	(30000 + 1)
#define MAX_LEN		(10 + 1)
#define LOGOUT		1
#define MAX_TIME	(50000 + 1)

template<typename Type>
struct LinkedList {
	struct ListNode {
		Type data;
		ListNode* next;
	};
	ListNode* head;
	ListNode* tail;

	void clear() { head = nullptr; tail = nullptr; }
	void push_back(const Type& data) {
		ListNode* node = new ListNode({ data, nullptr });
		if (head == nullptr) { head = node; tail = node; }
		else { tail->next = node; tail = node; }
	}
};

struct Data {
	char key[MAX_LEN];
	int value;

	Data(const char key[], int value) {
		strcpy(this->key, key);
		this->value = value;
	}
};

#define MAX_TABLE	50001
struct HashMap {
	LinkedList<Data> table[MAX_TABLE];

	void clear() { for (int i = 0; i < MAX_TABLE; i++) table[i].clear(); }
	int hashfunc(const char key[]) {
		unsigned long hash = 5381;
		int c;
		while (c = *key++) {
			hash = (((hash << 5) + hash) + c) % MAX_TABLE;
		}
		return hash % MAX_TABLE;
	}
	int find(const char key[]) {
		int hash = hashfunc(key);
		for (auto ptr = table[hash].head; ptr; ptr = ptr->next) {
			if (strcmp(ptr->data.key, key) == 0)
				return ptr->data.value;
		}
		return -1;
	}
	void emplace(const char key[], int value) {
		int hash = hashfunc(key);
		table[hash].push_back({ key, value });
	}
};

struct User {
	char password[MAX_LEN];
	int defaultTime;
	int logoutTime;
	int state;
};
User users[MAX_USERS];
int userCnt;
HashMap userMap;

int currentTime;
LinkedList<int> logoutUserList[MAX_TIME];

////////////////////////////////////////////////////////////////////
int get_userIndex(const char id[]) {
	int uIdx;
	auto ptr = userMap.find(id);
	if (ptr == -1) {
		uIdx = userCnt++;
		userMap.emplace(id, uIdx);
	}
	else { uIdx = ptr; }
	return uIdx;
}
////////////////////////////////////////////////////////////////////
void Init() {
	for (int i = 0; i < MAX_USERS; i++) { users[i] = {}; }
	userCnt = 0;
	userMap.clear();

	currentTime = 0;
	for (int i = 0; i < MAX_TIME; i++) { logoutUserList[i].clear(); }
}

void NewAccount(char id[], char password[], int defaulttime) {
	int uIdx = get_userIndex(id);
	strcpy(users[uIdx].password, password);
	users[uIdx].defaultTime = defaulttime;
	users[uIdx].logoutTime = currentTime + defaulttime;

	logoutUserList[users[uIdx].logoutTime].push_back(uIdx);
}

void Logout(char id[]) {
	int uIdx = get_userIndex(id);
	if (users[uIdx].state != LOGOUT) {
		users[uIdx].state = LOGOUT;
	}
}

void Connect(char id[], char password[]) {
	int uIdx = get_userIndex(id);
	if (strcmp(users[uIdx].password, password) != 0) { return; }
	if (users[uIdx].state != LOGOUT) {
		users[uIdx].logoutTime = currentTime + users[uIdx].defaultTime;
		logoutUserList[users[uIdx].logoutTime].push_back(uIdx);
	}
}

int Tick() {
	currentTime += 1;
	int ret = 0;

	for (auto ptr = logoutUserList[currentTime].head; ptr; ptr = ptr->next) {
		int uIdx = ptr->data;
		if (users[uIdx].state == LOGOUT) continue;

		if (users[uIdx].logoutTime == currentTime) {
			users[uIdx].state = LOGOUT;
			ret += 1;
		}
	}
	return ret;
}
```

### [STL] 복합화합물

```cpp
// STL 1093 ms
#ifndef _CRT_SECURE_NO_WARNINGS
#define _CRT_SECURE_NO_WARNINGS
#endif

#include <vector>
#include <unordered_map>
#include <string>
#include <cstring>
using namespace std;

#define MAX_COMPOUNDS	5000
#define MAX_LEN	11

// 500
typedef struct {
	char first[11];
	char second[11];
	char third[11];
	char fourth[11];
	char fifth[11];
}INFO;

extern int calc_correlation(const char str1[11], const char str2[11]);

struct Compound {
	INFO info;
};
Compound compounds[MAX_COMPOUNDS];
int compoundCnt;

unordered_map<string, vector<int>> firstMap;
unordered_map<string, vector<int>> secondMap;
unordered_map<string, vector<int>> thirdMap;
unordered_map<string, vector<int>> fourthMap;
unordered_map<string, vector<int>> fifthMap;

////////////////////////////////////////////////////////////////////////////////
int get_score(const INFO& info1, const INFO& info2) {
	int score = 0;
	int score1 = calc_correlation(info1.first, info2.first);
	int score2 = calc_correlation(info1.second, info2.second);
	int score3 = calc_correlation(info1.third, info2.third);
	int score4 = calc_correlation(info1.fourth, info2.fourth);
	int score5 = calc_correlation(info1.fifth, info2.fifth);

	if (score1 == 100 || score2 == 100 || score3 == 100 || score4 == 100 || score5 == 100) {
		score = score1 + score2 + score3 + score4 + score5;
	}
	return score;
}

////////////////////////////////////////////////////////////////////////////////
void init()
{
	for (int i = 0; i < MAX_COMPOUNDS; i++) { compounds[i] = {}; }
	compoundCnt = 0;
}

// 5,000
void addDB(INFO info)
{
	int cIdx = compoundCnt++;
	strcpy(compounds[cIdx].info.first, info.first);
	strcpy(compounds[cIdx].info.second, info.second);
	strcpy(compounds[cIdx].info.third, info.third);
	strcpy(compounds[cIdx].info.fourth, info.fourth);
	strcpy(compounds[cIdx].info.fifth, info.fifth);

	firstMap[string(info.first)].push_back(cIdx);
	secondMap[string(info.second)].push_back(cIdx);
	thirdMap[string(info.third)].push_back(cIdx);
	fourthMap[string(info.fourth)].push_back(cIdx);
	fifthMap[string(info.fifth)].push_back(cIdx);
}

int newCompound(INFO info)
{
	int ret = 0;

	for (auto cIdx: firstMap[string(info.first)]) {
		int score = get_score(info, compounds[cIdx].info);
		ret = max(ret, score);
	}
	for (auto cIdx : secondMap[string(info.second)]) {
		int score = get_score(info, compounds[cIdx].info);
		ret = max(ret, score);
	}
	for (auto cIdx : thirdMap[string(info.third)]) {
		int score = get_score(info, compounds[cIdx].info);
		ret = max(ret, score);
	}
	for (auto cIdx : fourthMap[string(info.fourth)]) {
		int score = get_score(info, compounds[cIdx].info);
		ret = max(ret, score);
	}
	for (auto cIdx : fifthMap[string(info.fifth)]) {
		int score = get_score(info, compounds[cIdx].info);
		ret = max(ret, score);
	}
	return ret;
}
```
