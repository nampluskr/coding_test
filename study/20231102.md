### [STL vector] 210908_물품보관

```cpp
// STL vector 8,403 ms
#include <vector>
using namespace std;

#define MAX_VALUES	(100000 + 1)

//vector<int> values;
int values[MAX_VALUES];
int valueCnt;

////////////////////////////////////////////////////////////////////
int get_leftMaxIndex(int left, int right) {
	int maxIdx = left;
	for (int i = left + 1; i <= right; i++) {
		if (values[i] > values[maxIdx]) { maxIdx = i; }
	}
	return maxIdx;
}

int get_rightMaxIndex(int left, int right) {
	int maxIdx = left;
	for (int i = left + 1; i <= right; i++) {
		if (values[i] >= values[maxIdx]) { maxIdx = i; }
	}
	return maxIdx;
}

int get_leftArea(int left, int right) {
	if (right < left) { return 0; }
	int loc = get_leftMaxIndex(left, right);
	int area = values[loc] * (right - loc + 1) + get_leftArea(left, loc - 1);
	return area;
}

int get_rightArea(int left, int right) {
	if (left > right) { return 0; }
	int loc = get_rightMaxIndex(left, right);
	int area = values[loc] * (loc - left + 1) + get_rightArea(loc + 1, right);
	return area;
}
////////////////////////////////////////////////////////////////////
void init(int N)
{
	//values.clear();	values.resize(N);
	for (int i = 0; i < N; i++) { values[i] = {}; }
	valueCnt = N;
}

int stock(int mLoc, int mBox)
{
	values[mLoc - 1] += mBox;
	int loc = get_leftMaxIndex(0, valueCnt - 1);
	int leftArea = get_leftArea(0, loc - 1);
	int rightArea = get_rightArea(loc + 1, valueCnt - 1);
	int ret = leftArea + values[loc] + rightArea;
	return ret;
}

int ship(int mLoc, int mBox)
{
	values[mLoc - 1] -= mBox;
	int loc = get_leftMaxIndex(0, valueCnt - 1);
	int leftArea = get_leftArea(0, loc - 1);
	int rightArea = get_rightArea(loc + 1, valueCnt - 1);
	int ret = leftArea + values[loc] + rightArea;
	return ret;
}

int getHeight(int mLoc)
{
	int ret = values[mLoc - 1];
	return ret;
}
```
### [Partition] 210908_물품보관

```cpp
// STL vector 8,403 ms / Manual 397 ms
//#include <vector>
#include <cmath>
//using namespace std;

#define MAX_VALUES	(100000 + 1)

inline int min(int a, int b) { return (a < b) ? a : b; }

//vector<int> values;
int values[MAX_VALUES];
int valueCnt;

struct Data {
	int value;
	int leftIdx;
	int rightIdx;

	void update_leftMax(int value, int idx) {
		if (value > this->value) {
			this->value = value;
			this->leftIdx = idx;
		}
	}
	void update_rightMax(int value, int idx) {
		if (value >= this->value) {
			this->value = value;
			this->rightIdx = idx;
		}
	}
};

int num_values;
int bucket_size;
int num_buckets;

struct Partition {
	//vector<Data> buckets;
	Data buckets[MAX_VALUES];
	int N;		// Data size

	void init() {
		N = bucket_size;
		//buckets.clear();	buckets.resize(num_buckets);

		for (int i = 0; i < num_buckets; i++) {
			int left = i * N;
			int right = min((i + 1) * N - 1, num_values - 1);
			buckets[i] = { 0, left, right };
		}
	}
	void update(int idx, int value) {
		int bIdx = idx / N;
		int left = bIdx * N;
		int right = min((bIdx + 1) * N - 1, num_values - 1);

		//if (idx == buckets[bIdx].leftIdx) {
		//	buckets[bIdx] = { values[left], left, left };
		//	for (int i = left + 1; i <= right; i++) {
		//		buckets[bIdx].update_leftMax(values[i], i);
		//	}
		//}
		//else { buckets[bIdx].update_leftMax(values[idx], idx); }

		buckets[bIdx] = { values[left], left, left };
		for (int i = left + 1; i <= right; i++) {
			buckets[bIdx].update_leftMax(values[i], i);
			buckets[bIdx].update_rightMax(values[i], i);
		}
	}
	int get_leftMaxIndex(int left, int right) {
		Data ret = { 0, left, left };
		int s = left / N;
		int e = right / N;

		if (s == e) {
			for (int i = left; i <= right; i++) { ret.update_leftMax(values[i], i); }
			return ret.leftIdx;
		}
		while (left / N == s) { ret.update_leftMax(values[left], left); left++; }
		while (right / N == e) { ret.update_leftMax(values[right], right); right--; }
		for (int i = s + 1; i <= e - 1; i++) { 
			ret.update_leftMax(buckets[i].value, buckets[i].leftIdx);
		}
		return ret.leftIdx;
	}
	int get_rightMaxIndex(int left, int right) {
		Data ret = { 0, left, left };
		int s = left / N;
		int e = right / N;

		if (s == e) {
			for (int i = left; i <= right; i++) { ret.update_rightMax(values[i], i); }
			return ret.rightIdx;
		}
		while (left / N == s) { ret.update_rightMax(values[left], left); left++; }
		while (right / N == e) { ret.update_rightMax(values[right], right); right--; }
		for (int i = s + 1; i <= e - 1; i++) {
			ret.update_rightMax(buckets[i].value, buckets[i].rightIdx);
		}
		return ret.rightIdx;
	}
};
Partition part;

////////////////////////////////////////////////////////////////////
//int get_leftMaxIndex(int left, int right) {
//	int maxIdx = left;
//	for (int i = left + 1; i <= right; i++) {
//		if (values[i] > values[maxIdx]) { maxIdx = i; }
//	}
//	return maxIdx;
//}
//
//int get_rightMaxIndex(int left, int right) {
//	int maxIdx = left;
//	for (int i = left + 1; i <= right; i++) {
//		if (values[i] >= values[maxIdx]) { maxIdx = i; }
//	}
//	return maxIdx;
//}

int get_leftArea(int left, int right) {
	if (right < left) { return 0; }
	//int loc = get_leftMaxIndex(left, right);
	int loc = part.get_leftMaxIndex(left, right);
	int area = values[loc] * (right - loc + 1) + get_leftArea(left, loc - 1);
	return area;
}

int get_rightArea(int left, int right) {
	if (left > right) { return 0; }
	//int loc = get_rightMaxIndex(left, right);
	int loc = part.get_rightMaxIndex(left, right);
	int area = values[loc] * (loc - left + 1) + get_rightArea(loc + 1, right);
	return area;
}
////////////////////////////////////////////////////////////////////
void init(int N)
{
	//values.clear();	values.resize(N);
	for (int i = 0; i < N; i++) { values[i] = {}; }
	valueCnt = N;

	num_values = N;
	bucket_size = sqrt(num_values);
	num_buckets = ceil((double)num_values / bucket_size);
	part.init();
}

int stock(int mLoc, int mBox)
{
	values[mLoc - 1] += mBox;
	part.update(mLoc - 1, mBox);

	int loc = part.get_leftMaxIndex(0, valueCnt - 1);
	int leftArea = get_leftArea(0, loc - 1);
	int rightArea = get_rightArea(loc + 1, valueCnt - 1);
	int ret = leftArea + values[loc] + rightArea;
	return ret;
}

int ship(int mLoc, int mBox)
{
	//values[mLoc - 1] -= mBox;
	//part.update(mLoc - 1, -mBox);

	//int loc = part.get_leftMaxIndex(0, valueCnt - 1);
	//int leftArea = get_leftArea(0, loc - 1);
	//int rightArea = get_rightArea(loc + 1, valueCnt - 1);
	//int ret = leftArea + values[loc] + rightArea;
	int ret = stock(mLoc, -mBox);

	return ret;
}

int getHeight(int mLoc)
{
	int ret = values[mLoc - 1];
	return ret;
}
```
###
