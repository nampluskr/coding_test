### [STL] 230127_기지국설치

```cpp
// STL 560 ms
#include <vector>
#include <unordered_map>
#include <queue>
using namespace std;

#define MAX_BUILDINGS	(24000 + 1)
#define ADDED			0
#define REMOVED			1

struct Building {
	//int ID;
	int idx;
	int loc;
	int state;
};
vector<Building> buildings;
int addCnt;
int removeCnt;
unordered_map<int, int> buildingMap;

struct Data {
	int loc, idx;
	bool operator<(const Data& data) const { return loc > data.loc; }
};
vector<int> locations;

////////////////////////////////////////////////////////////////////
void sortLocations() {
	priority_queue<Data> heap;

	for (int i = 0; i < addCnt; i++) {
		if (buildings[i].state == REMOVED) continue;
		heap.push({ buildings[i].loc, buildings[i].idx });
	}

	locations.clear(); locations.resize(MAX_BUILDINGS);
	int i = 0;
	while (!heap.empty()) {
		int bIdx = heap.top().idx; heap.pop();
		locations[i++] = buildings[bIdx].loc;
	}
}

int get_buildingIndex(int mId) {
	int bIdx;
	auto ptr = buildingMap.find(mId);
	if (ptr == buildingMap.end()) {
		bIdx = addCnt++;
		buildingMap.emplace(mId, bIdx);
	}
	else { 
		bIdx = ptr->second;
		if (buildings[bIdx].state == REMOVED) {
			buildings[bIdx].state = ADDED;
			removeCnt -= 1;
		}
	}
	return bIdx;
}

// [결정 문제] 기지국 사이 거리 x 이면 기지국의 개수는 target 개 이상인가?
bool condition(int x, int target) {
	int cnt = 1;
	int cur = locations[0];
	for (int i = 1; i < addCnt - removeCnt; i++) {
		if (locations[i] - cur >= x) {
			cnt += 1;
			cur = locations[i];
		}
	}
	return cnt >= target;
}

// [최적화 문제] M 개의 기지국 설치시 기지국간 사이의 최대 거리는?
int search(int low, int high, int target) {
	int sol = low;
	while (low <= high) {
		int mid = (low + high) / 2;
		if (condition(mid, target)) { sol = mid; low = mid + 1; }
		else { high = mid - 1; }
	}
	return sol;
}
////////////////////////////////////////////////////////////////////
void init(int N, int mId[], int mLocation[])
{
	buildings.clear();	buildings.resize(MAX_BUILDINGS);
	addCnt = 0;
	removeCnt = 0;
	buildingMap.clear();

	for (int i = 0; i < N; i++) {
		int bIdx = get_buildingIndex(mId[i]);
		//buildings[bIdx].ID = mId[i];
		buildings[bIdx].idx = bIdx;
		buildings[bIdx].loc = mLocation[i];
		buildings[bIdx].state = ADDED;
	}
}

int add(int mId, int mLocation)
{
	int bIdx = get_buildingIndex(mId);
	//buildings[bIdx].ID = mId;
	buildings[bIdx].idx = bIdx;
	buildings[bIdx].loc = mLocation;
	buildings[bIdx].state = ADDED;

	int ret = addCnt - removeCnt;
	return ret;
}

int remove(int mStart, int mEnd)
{
	for (int i = 0; i <= addCnt; i++) {
		if (buildings[i].state == REMOVED) continue;

		if (mStart <= buildings[i].loc && buildings[i].loc <= mEnd) {
			buildings[i].state = REMOVED;
			removeCnt += 1;
		}
	}
	int ret = addCnt - removeCnt;
	return ret;
}

int install(int M)
{
	sortLocations();

	int low = 1;
	int high = locations[addCnt - removeCnt - 1] - locations[0];
	int ret = search(low, high, M);
	return ret;
}
```

### [Manual] 230127_기지국설치

```cpp
// STL 560 ms, Manual 401 ms
//#include <vector>
//#include <unordered_map>
//#include <queue>
//using namespace std;

#define MAX_BUILDINGS	(100 + 24000 + 1)
#define ADDED			0
#define REMOVED			1

template<typename Type>
struct LinkedList {
	struct ListNode {
		Type data;
		ListNode* next;
	};
	ListNode* head;
	ListNode* tail;

	void clear() { head = nullptr; tail = nullptr; }
	void push_back(const Type& data) {
		ListNode* node = new ListNode({ data, nullptr });
		if (head == nullptr) { head = node; tail = node; }
		else { tail->next = node; tail = node; }
	}
};

#define MAX_TABLE	MAX_BUILDINGS
struct IntHashMapInt {
	struct Pair {
		int key;
		int value;
	};
	LinkedList<Pair> table[50007];

	void clear() { for (int i = 0; i < MAX_TABLE; i++) table[i].clear(); }
	int find(int key) {
		int hash = key % MAX_TABLE;
		for (auto ptr = table[hash].head; ptr; ptr = ptr->next) {
			if (ptr->data.key == key)
				return ptr->data.value;
		}
		return -1;
	}
	void emplace(int key, int value) {
		int hash = key % MAX_TABLE;
		table[hash].push_back({ key, value });
	}
};

#define MAX_HEAP	MAX_BUILDINGS
template<typename Type>
struct PriorityQueue {
	//priority_queue<Type> heap;
	Type heap[MAX_HEAP];
	int heapSize;

	void clear() { heapSize = 0; }
	void push(const Type& data) {
		heap[heapSize] = data;
		int current = heapSize;

		while (current > 0 && heap[(current - 1) / 2] < heap[current]) {
			Type temp = heap[(current - 1) / 2];
			heap[(current - 1) / 2] = heap[current];
			heap[current] = temp;
			current = (current - 1) / 2;
		}
		heapSize = heapSize + 1;
	}
	void pop() {
		heapSize = heapSize - 1;
		heap[0] = heap[heapSize];
		int current = 0;

		while (current * 2 + 1 < heapSize) {
			int child;
			if (current * 2 + 2 == heapSize) {
				child = current * 2 + 1;
			}
			else {
				child = heap[current * 2 + 2] < heap[current * 2 + 1] ? current * 2 + 1 : current * 2 + 2;
			}
			if (heap[child] < heap[current]) {
				break;
			}
			Type temp = heap[current];
			heap[current] = heap[child];
			heap[child] = temp;
			current = child;
		}
	}
	Type top() { return heap[0]; }
	bool empty() { return heapSize == 0; }
};

////////////////////////////////////////////////////////////////////
struct Building {
	//int ID;
	int idx;
	int loc;
	int state;
};
//vector<Building> buildings;
Building buildings[MAX_BUILDINGS];
int addCnt;
int removeCnt;
//unordered_map<int, int> buildingMap;
IntHashMapInt buildingMap;

struct Data {
	int loc, idx;
	bool operator<(const Data& data) const { return loc > data.loc; }
};
//vector<int> locations;
int locations[MAX_BUILDINGS];

////////////////////////////////////////////////////////////////////
void sort_locations() {
	PriorityQueue<Data> Q; Q.clear();

	for (int i = 0; i < addCnt; i++) {
		if (buildings[i].state == REMOVED) continue;
		Q.push({ buildings[i].loc, buildings[i].idx });
	}

	//locations.clear(); locations.resize(MAX_BUILDINGS);
	//for (int i = 0; i < addCnt - removeCnt; i++) { locations[i] = {}; }
	int i = 0;
	while (!Q.empty()) {
		int bIdx = Q.top().idx; Q.pop();
		locations[i++] = buildings[bIdx].loc;
	}
}

int get_buildingIndex(int mId) {
	int bIdx;
	auto ptr = buildingMap.find(mId);
	if (ptr == -1) {
		bIdx = addCnt++;
		buildingMap.emplace(mId, bIdx);
	}
	else {
		bIdx = ptr;
		if (buildings[bIdx].state == REMOVED) {
			buildings[bIdx].state = ADDED;
			removeCnt -= 1;
		}
	}
	return bIdx;
}

// [결정 문제] 기지국 사이 거리 x 이면 기지국의 개수는 target 개 이상인가?
bool condition(int x, int target) {
	int cnt = 1;
	int cur = locations[0];
	for (int i = 1; i < addCnt - removeCnt; i++) {
		if (locations[i] - cur >= x) {
			cnt += 1;
			cur = locations[i];
		}
	}
	return cnt >= target;
}

// [최적화 문제] M 개의 기지국 설치시 기지국간 사이의 최대 거리는?
int search(int low, int high, int target) {
	int sol = low;
	while (low <= high) {
		int mid = (low + high) / 2;
		if (condition(mid, target)) { sol = mid; low = mid + 1; }
		else { high = mid - 1; }
	}
	return sol;
}

////////////////////////////////////////////////////////////////////
void init(int N, int mId[], int mLocation[])
{
	//buildings.clear();	buildings.resize(MAX_BUILDINGS);
	for (int i = 0; i < MAX_BUILDINGS; i++) { buildings[i] = {}; }
	addCnt = 0;
	removeCnt = 0;
	buildingMap.clear();

	for (int i = 0; i < N; i++) {
		int bIdx = get_buildingIndex(mId[i]);
		//buildings[bIdx].ID = mId[i];
		buildings[bIdx].idx = bIdx;
		buildings[bIdx].loc = mLocation[i];
		buildings[bIdx].state = ADDED;
	}
}

int add(int mId, int mLocation)
{
	int bIdx = get_buildingIndex(mId);
	//buildings[bIdx].ID = mId;
	buildings[bIdx].idx = bIdx;
	buildings[bIdx].loc = mLocation;
	buildings[bIdx].state = ADDED;

	int ret = addCnt - removeCnt;
	return ret;
}

int remove(int mStart, int mEnd)
{
	for (int i = 0; i <= addCnt; i++) {
		if (buildings[i].state == REMOVED) continue;

		if (mStart <= buildings[i].loc && buildings[i].loc <= mEnd) {
			buildings[i].state = REMOVED;
			removeCnt += 1;
		}
	}
	int ret = addCnt - removeCnt;
	return ret;
}

int install(int M)
{
	sort_locations();

	int low = 1;
	int high = locations[addCnt - removeCnt - 1] - locations[0];
	int ret = search(low, high, M);
	return ret;
}
```
